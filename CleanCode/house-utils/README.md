## Clean Code [로버트 C.마틴]

### Day 01. 클린 코드란?, 의미있는 이름에 대해.
#### 나쁜 코드
- 성능이 나쁜 코드: 불필요한 연산이 들어가서 개선의 여지가 있는 코드
- 의미가 모호한 코드: 이해하기 어려운 코드, 네이밍과 그 내용이 다른 코드
- 중복된 코드: 비슷한 내용인데 중복되는 코드들은 버그를 낳는다.
#### 클린코드
- 성능이 좋은 코드
- 의미가 명확한 코드 = 가독성이 좋은 코드
- 중복이 제거된 코드
#### 의미있는 이름 (네이밍)은 중요하다.
- 코드가 무엇을 말하는지 알수 있다.
- 현업에서 통일성 있게 구현해야 코드를 분석할 떄 더욱 쉽다.
- 클래스는 명사, 명사구
- 메서드는 동사, 동사구
- 모든 클래스와 메서드는 하나의 역할만 할 수 있도록 해야한다.
- [Google Java Style Guide](https://google.github.io/styleguide/javaguide.html#s5-naming) 



### Day 02. 함수 - 함수를 안전하고 간결하게 작성하기

#### SOLID

##### 객체지향 설계의 5가지 원칙

- **SRP 단일 책임원칙** 
  - 클래스는 하나의 기능만 가지며, 어떤 변화에 의해 클래스를 변경해야 하는 이유는 오직 하나뿐이여야 함.
  - SRP 책임이 분명해지기 때문에, 변경에 의한 연쇄작용에서 자유로워질 수 있다. (독립성)
  - 가독성 향상, 유지보수 용의
- **OCP 개방-폐쇄 원칙**
  - 소프트웨어 요소는 확장에는 열려 있으나, 변경에는 닫혀 있어야 한다.
  - 요구사항의 변경이나 추가사항이 발생하더라도, 기존 구성요소에는 수정이 일어나지 않고 기존 구성 요소를 쉽게 확장해서 재사용.
  - 객체지향의 추상화와 다형성 활용.
- **LSP 리스코프 치환 원칙**
  - 서브 타입은 기반 타입이 약속한 규약(접근제한자, 예외포함)을 지켜야 한다.
  - 클래스 상속, 인터페이스 상속을 이용해 확장성을 획득한다.
  - 다형성과 확장성을 극대화하기 위해 인터페이스를 사용하는 곳이 좋다.
- **ISP 인터페이스 분리 원칙**
  - 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다.
  - 인터페이스 단일 책임
  - 만약 어떤 클래스를 이용하는 클라이언트가 여러개고 이들이 클래스의 특정부분만 이용한다면, 여러 인터페이스로 분류하여 클라이언트가 필요한 기능만 전달.
- **DIP 의존성 역전 원칙**
  - 상위 모델은 하위 모델에 의존하면 안된다. 둘 다 추상화에 의존해야 한다.
  - 추상화는 세부 사항에 의존하면 안된다. 세부 사항은 추상화에 따라 달라진다.

#### 간결한 함수 작성하기

- 작게 쪼갠다.
- 함수 내 추상화 수준을 동일하게 맞춤.
- 한가지만 할 수 있도록.
- 변경에 닫게 만들기.
- 분기할 때는 Factory 내부에서 할 수 있도록
- 함수 인수는 0-2개가 적당하다. 3개 이상일 경우는 객체를 인자로 넘기는 것으로.

#### 안전한 함수 작성하기

- 부수효과(side effect)가 없는 함수 - 값을 반환하는 함수가 외부 상태를 변경하는 경우

#### 함수 리팩터링

- 기능을 구현하는 서투른 함수를 작성한다
- 테스트 코드를 작성한다
- 리팩터링 한다.



